#!/usr/bin/env bash
#
# lock - Encrypt files/folders with AES-256-CBC
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Source library functions
source "$PROJECT_ROOT/lib/utils.sh"

VERBOSE=false
RECURSIVE=false
PASSWORD=""
DRY_RUN=false

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [--] FILE...

Encrypt files/folders using AES-256-CBC encryption.

Options:
    -h, --help           Show this help message
    -v, --verbose        Enable verbose output
    -R, --recursive      Recursively lock directory contents
    -p, --password=PASS  Password for encryption (prompted if not provided)
    -n, --dry-run        Show what would be locked without making changes

Arguments:
    FILE...          One or more files or folders to lock

Examples:
    $(basename "$0") file.txt
    $(basename "$0") -v folder1 folder2
    $(basename "$0") -- -file-starting-with-dash.txt

EOF
}

verbose_log() {
    if [[ "$VERBOSE" == true ]]; then
        log_info "$@"
    fi
}

# Encode a filename using AES-256-CBC encryption (URL-safe base64 output)
encode_name() {
    local name="$1"
    local password="$2"
    # Encrypt with AES-256-CBC, output as base64, then make URL-safe
    printf '%s' "$name" | openssl enc -aes-256-cbc -salt -pbkdf2 -base64 -pass pass:"$password" | tr '+/' '-_' | tr -d '=' | tr -d '\n'
}

encode_file() {
    local file="$1"
    local tmpfile

    tmpfile="$(mktemp)"
    if openssl enc -aes-256-cbc -salt -pbkdf2 -base64 -pass pass:"$PASSWORD" -in "$file" -out "$tmpfile"; then
        mv "$tmpfile" "$file"
        return 0
    else
        rm -f "$tmpfile"
        return 1
    fi
}

lock_item() {
    local item="$1"
    local dir basename newname newpath
    local result=0

    # Check if item exists
    if [[ ! -e "$item" ]]; then
        log_error "No such file or directory: $item"
        return 1
    fi

    # Get directory and basename
    dir="$(dirname "$item")"
    basename="$(basename "$item")"

    # If recursive and it's a directory, process contents first
    if [[ "$RECURSIVE" == true && -d "$item" ]]; then
        local entry
        while IFS= read -r -d '' entry; do
            if ! lock_item "$entry"; then
                result=1
            fi
        done < <(find "$item" -maxdepth 1 -mindepth 1 -print0)
    fi

    # Create new encrypted name
    newname="$(encode_name "$basename" "$PASSWORD")"
    newpath="$dir/$newname"

    # Dry-run mode: just show what would happen
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would lock: $item -> $newpath"
        return $result
    fi

    # Check if target already exists
    if [[ -e "$newpath" ]]; then
        log_error "Target already exists: $newpath"
        return 1
    fi

    # Encode file contents if it's a regular file
    if [[ -f "$item" ]]; then
        if ! encode_file "$item"; then
            log_error "Failed to encode: $item"
            return 1
        fi
        verbose_log "Encoded: $item"
    fi

    # Perform the rename
    if ! mv "$item" "$newpath"; then
        log_error "Failed to lock: $item"
        return 1
    fi

    verbose_log "Locked: $item -> $newpath"
    return $result
}

main() {
    # Parse options with getopt (supports long options)
    local opts
    if ! opts=$(getopt -o hvRp:n --long help,verbose,recursive,password:,dry-run -n "$(basename "$0")" -- "$@"); then
        >&2 usage
        exit 1
    fi
    eval set -- "$opts"

    while true; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -R|--recursive)
                RECURSIVE=true
                shift
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                die "Invalid option: $1"
                ;;
        esac
    done

    # Prompt for password if not provided (with confirmation)
    if [[ -z "$PASSWORD" ]]; then
        PASSWORD="$(prompt_password_confirm)"
    fi

    # Warn about short passwords
    warn_short_password "$PASSWORD"

    # Check for remaining arguments (files/folders)
    if [[ $# -eq 0 ]]; then
        log_error "No files or folders specified"
        >&2 usage
        exit 1
    fi

    # Process each file/folder
    local exit_code=0
    for item in "$@"; do
        if ! lock_item "$item"; then
            exit_code=1
        fi
    done

    exit "$exit_code"
}

main "$@"
